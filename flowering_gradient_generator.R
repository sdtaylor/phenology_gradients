

# Generate x,y points in a clumped fashion. 
# The number of clump centers is a poisson dist. with lambda=5.
# Optionally set the the percentage of points n which
# will be drawn from a spatially uniform distribution. This results
# in clumped points that are not "too" clumped. 
generate_clustered_points = function(n,
                                     xlimits,
                                     ylimits,
                                     uniform_random_percent=0.2){
  uniform_n = floor(n * uniform_random_percent)
  clumped_n = n - uniform_n
  point_pattern = spatstat::rThomas(5, 0.05, clumped_n*1.5)
  
  # Spatstat will generate a random number of points, so from
  # those choose the n points requested.
  number_of_random_points = length(point_pattern$x)
  if(number_of_random_points < clumped_n){
    # If not enough random points were generated by spatstat try again
    return(generate_clustered_points(n=n, 
                                     xlimits=xlimits,
                                     ylimits=ylimits, 
                                     uniform_random_percent = uniform_random_percent))
  } else {
    uniform_x = runif(n=uniform_n, min=0, max=1)
    uniform_y = runif(n=uniform_n, min=0, max=1)
    random_selection = sample(1:number_of_random_points, size = clumped_n,replace = FALSE)
    x = c(point_pattern$x[random_selection], uniform_x)
    y = c(point_pattern$y[random_selection], uniform_y)
    return(dplyr::tibble(x=x, y=y))
  }
}

spatialFloweringSampler = function(n,
                                   x=NULL,
                                   y=NULL,
                                   sample_type='po',
                                   # po: presence only, pa: presence and absence
                                   fraction_present=0.8,
                                   distribution_type='a',
                                   # a: normal-ish curve, b: beta-ish curve, c: uniform-ish curve
                                   xlimits = c(0,1),
                                   ylimits = c(0,1),
                                   start_doy = 180,
                                   flowering_length = 30,
                                   flowering_gradient = 10/0.1,
                                   clustering=FALSE,
                                   clustering_uniform_random_percent=0.2){
  
  # Generate n points from a spatial domain of flowering
    
  if(clustering) {
    clustered_points = generate_clustered_points(n=n,
                                                 xlimits=xlimits,ylimits=ylimits,
                                                 uniform_random_percent=clustering_uniform_random_percent)
    x = clustered_points$x
    y = clustered_points$y
  } else if(is.null(x) && is.null(y)) {
    # Generate spatially uniform points      
    x=runif(n=n, min=xlimits[1], max=xlimits[2])
    y=runif(n=n, min=ylimits[1], max=ylimits[2])
  } else {
    # User user supplied points
    if(length(x)!=length(y)){stop('x and y must have the same length')}
    if(length(x)!=n){stop('x and y must be the same as n')}
  }

  # make weights for each julian day corresponding to the chance of observing an open flower
  # corresponds to flower abundance
  doy_probabilites = rep(0, 365)
  if(distribution_type=='a'){
    doy_probabilites[start_doy:(start_doy+flowering_length-1)] = dnorm(seq(from=-3,to=3, length.out = flowering_length))
  } else if(distribution_type=='b'){
    doy_probabilites[start_doy:(start_doy+flowering_length-1)] = dbeta(seq(from=0,to=1, length.out = flowering_length), shape1=2, shape2=5)
  } else if(distribution_type=='c'){
    stop('type c not implemented yet')
  }
  
  doy = sample(1:365)
  
  # presences and absences included
  if(sample_type=='pa'){
    num_presence = ceiling(n*fraction_precent)
    num_absence  = n - num_presence
    
    doy =  sample(1:365, size=num_presence, replace=T, prob = doy_probabilites)
    doy =  c(doy,sample(1:365, size=num_absence, replace=T, prob = max(doy_probabilites) - doy_probabilites))
    flower_present = c(rep.int(1,num_presence),rep.int(0,num_absence))
  # only presences
  } else if(sample_type=='po'){
    doy = sample(1:365, size=n, replace=T, prob = doy_probabilites)
    flower_present = rep.int(1,n)
  } else {
    stop(paste0('unknown sample type: ',sample_type))
  }
  
  # for each point, transform the probability according to the flowering gradient
  #y_center = ylimits[2] - ((ylimits[2] - ylimits[1])/2)
  #y_scaled = y - y_center
  
  doy = doy + round(y * flowering_gradient, 0)
  
  true_start_doy = rep.int(start_doy, n)
  true_start_doy = true_start_doy + round(y * flowering_gradient, 0)
  
  return(data_frame(x=x,y=y,doy=doy,flower_present=flower_present, true_start_doy=true_start_doy))
}

spatialFloweringGrid = function(xlimits = c(0,1),
                                ylimits = c(0,1),
                                cell_size = 0.05,
                                start_doy = 180,
                                flowering_length = 30,
                                flowering_gradient = 10/0.1){
  # Generate an x/y grid of the flowering gradient.
  # Returns a data.frame of:
  
  #x, y, onset
  full_grid = expand.grid(x=seq(xlimits[1], xlimits[2], by=cell_size),
                          y=seq(ylimits[1], ylimits[2], by=cell_size))
  
  full_grid$onset = start_doy + round(full_grid$y * flowering_gradient, 0)
  
  return(full_grid)
}
